(in-package :vs-haskell)

(cogef:copy 'unify:unify 'unify)

(defun envar(thing)
  (intern(format nil "?~A"thing)))

(defun patternize(thing)
  (if(millet:type-specifier-p thing)
    thing
    (if(listp thing)
      (trestrul:mapleaf #'patternize thing)
      (Envar thing))))

(defun enwild (type-spec)
  (sublis'((* . _)(T . _))type-spec))

(defun dewild (pattern)
  (subst '* '_ pattern))

(defmethod unify :around ((a symbol)(b symbol)
				&optional (env (unify:make-empty-environment))
				&key &allow-other-keys)
  (cond ((unify:variable-any-p a)env)
	((unify:variablep a)(unify::var-unify a b env))
	((unify:variable-any-p b) env)
	((unify:variablep b)(unify::var-unify b a env))
	((eq a b)env)
	((subtype? b a)env)
	(t (error 'unify::unification-failure
		  :format-control "Cannot unify two different symbols: ~S ~S"
		  :format-arguments (list a b)))))

(defmethod unify ((a (eql t))(b list)
			&optional (env (unify:make-empty-environment))
			&key &allow-other-keys)
  (extend-environment-with-t b env))

(defun extend-environment-with-t(pattern env)
  (trestrul:traverse (lambda(x)
		       (when(and (unify:variablep x)
				 (null(nth-value 1 (unify:find-variable-value x env))))
			 (unify:extend-environment x t env)))
		     pattern)
  env)

(defmethod unify ((b list)(a (eql t))
			&optional (env (unify:make-empty-environment))
			&key &allow-other-keys)
  (extend-environment-with-t b env))

(defmethod unify ((a (eql 'function))(b list)
			&optional (env (unify:make-empty-environment))
			&key &allow-other-keys)
  (if(eq 'function (car b))
    (unify t b env)
    (if(not(unify:variablep(car b)))
      (call-next-method)
      (if(cdddr b)
	(call-next-method)
	(if(unify:find-variable-value (car b)env)
	  (extend-environment-with-t (cdr b)env)
	  (extend-environment-with-t (cdr b)
				     (unify:extend-environment (car b) a env)))))))

(defmethod unify ((b list)(a (eql 'function))
			&optional (env (unify:make-empty-environment))
			&key &allow-other-keys)
  (if(eq 'function (car b))
    (unify t b env)
    (if(not(unify:variablep(car b)))
      (call-next-method)
      (if(cdddr b)
	(call-next-method)
	(if(unify:find-variable-value (car b)env)
	  (extend-environment-with-t (cdr b)env)
	  (extend-environment-with-t (cdr b)
				     (unify:extend-environment (car b) a env)))))))

(defmethod unify ((a (eql 'cons))(b list)
			&optional(env(unify:make-empty-environment))
			&key &allow-other-keys)
  (if(unify:variablep(car b))
    (extend-environment-with-t (cdr b)
			       (unify:extend-environment(car b)a env))
    (call-next-method)))

(defmethod unify ((b list)(a (eql 'cons))
			&optional(env(unify:make-empty-environment))
			&key &allow-other-keys)
  (if(unify:variablep(car b))
    (extend-environment-with-t (cdr b)
			       (unify:extend-environment(car b)a env))
    (call-next-method)))

(defmethod unify ((a (eql 'null))(b list)
			&optional(env(unify:make-empty-environment))
			&key &allow-other-keys)
  (if(not(unify:variablep(car b)))
    (call-next-method)
    (if(cddr b)
      (call-next-method)
      (extend-environment-with-t (cdr b)
				 (unify:extend-environment(car b)'list env)))))

(defmethod unify ((b list)(a (eql 'null))
			&optional(env(unify:make-empty-environment))
			&key &allow-other-keys)
  (if(not(unify:variablep(car b)))
    (call-next-method)
    (if(cddr b)
      (call-next-method)
      (extend-environment-with-t (cdr b)
				 (unify:extend-environment(car b)'list env)))))

(defmethod unify :around ((a list)(b list)
				&optional(env(unify:make-empty-environment))
				&key &allow-other-keys)
  (trivia:match*((car a)(car b))
    (((satisfies unify:variablep)(eq 'function))
     (unify (cdr a)(cddr b)
		  (unify:extend-environment (car a) (car b) env)))
    (((eq 'function)(satisfies unify:variablep))
     (unify (cddr a)(cdr b)
		  (unify:extend-environment (car a)(car b)env)))
    ((_ _)(call-next-method))))

(defun subtype?(t1 t2)
  (if(millet:type-specifier-p t1)
    (if(millet:type-specifier-p t2)
      (subtypep t1 t2)
      (or (eql t t1)
	  (unify t1 (patternize t2))))
    (if(millet:type-specifier-p t2)
      (unless(eql t t2)
	(unify (patternize t1)t2))
      (unify (patternize t1)(patternize t2)))))

