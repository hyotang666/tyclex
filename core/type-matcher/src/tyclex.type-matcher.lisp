(defpackage :tyclex.type-matcher
  (:use :cl :tyclex.newtype :tyclex.unifier)
  (:shadowing-import-from :tyclex.newtype #:list)
  (:import-from :tyclex.objects.adt #:adt-type-specifier-p)
  (:export
    #:type-match-p
    ))
(in-package :tyclex.type-matcher)

(defmethod Unify :around ((a symbol)(b symbol)
			  &optional (env (Make-empty-environment))
			  &key &allow-other-keys)
  (cond ((Variable-any-p a)env)
	((Variablep a)(tyclex.unifier::var-unify a b env))
	((Variable-any-p b) env)
	((Variablep b)(tyclex.unifier::var-unify b a env))
	((eq a b)env)
	((type-match-p b a T)env)
	(t (call-next-method))))

(defmacro defunify(lambda-list &body body)
  `(PROGN (DEFMETHOD UNIFY(,@lambda-list
			    &OPTIONAL (ENV (MAKE-EMPTY-ENVIRONMENT))
			    &KEY &ALLOW-OTHER-KEYS)
		     ,@body)
	  (DEFMETHOD UNIFY(,@(reverse lambda-list)
			    &OPTIONAL (ENV (MAKE-EMPTY-ENVIRONMENT))
			    &KEY &ALLOW-OTHER-KEYS)
		     ,@body)))

(defunify((a (eql t))(b cl:list))
  (extend-environment-with-t b env))

(defun extend-environment-with-t(pattern env)
  (trestrul:traverse (lambda(x)
		       (when(and (variablep x)
				 (null(nth-value 1 (Find-variable-value x env))))
			 (Extend-environment x t env)))
		     pattern)
  env)

(defunify((a (eql 'function))(b cl:list))
  (if(eq 'function (car b))
    (Unify t b env)
    (if(not(Variablep(car b)))
      (call-next-method)
      (if(cdddr b)
	(call-next-method)
	(if(Find-variable-value (car b)env)
	  (extend-environment-with-t (cdr b)env)
	  (extend-environment-with-t (cdr b)
				     (Extend-environment (car b) a env)))))))

(defunify((a (eql 'cons))(b cl:list))
  (if(Variablep(car b))
    (extend-environment-with-t (cdr b)
			       (Extend-environment(car b)a env))
    (if(eq 'list (car b))
      env
      (call-next-method))))

(defunify((a (eql 'null))(b cl:list))
  (if(not(Variablep(car b)))
    (if(or (eq 'cl:list (car b))
	   (eq 'list (car b)))
      (let((variable(find-value-variable a env)))
	(if variable
	  (replace-bind variable b env)
	  (call-next-method)))
      (call-next-method))
    (if(cddr b)
      (call-next-method)
      (extend-environment-with-t (cdr b)
				 (Extend-environment(car b)'list env)))))

(defunify((a (eql 'null))(b (eql 'cons)))
  (let((variable(find-value-variable a env)))
    (if variable
      (replace-bind variable b env)
      env)))

#++original[fail]
; I do not why this code fails to unexpected diverge. (in SBCL, ECL)
(defmethod Unify :around ((a cl:list)(b cl:list)
			  &optional(env(Make-empty-environment))
			  &key &allow-other-keys)
  (matrix-case:matrix-etypecase((car a)(car b))
    (((satisfies Variablep)(eql function))
     (setf b (ensure-value b))
     (Unify (cdr a)
	    (or (cddr b) ; lisp style, e.g. (function(arg)return)
		(cdr b)) ; probably haskell style, e.g. (function return).
	    (Extend-environment (car a) (car b) env)))
    (((eql function)(satisfies Variablep))
     (setf a (ensure-value a))
     (Unify (or (cddr a) ; lisp style, e.g. (function(arg)return)
		(cdr a)) ; probably haskell style, e.g. (function return).
	    (cdr b)
	    (Extend-environment (car b)(car a)env)))
    (otherwise (call-next-method))))

;#++macroexpand-1ed-when-readtime[success]
; I do not why but this one works. (in ECL, SBCL)
(defmethod Unify :around ((a cl:list)(b cl:list)
			  &optional(env(Make-empty-environment))
			  &key &allow-other-keys)
  #.(macroexpand-1'(matrix-case:matrix-etypecase((car a)(car b))
		     (((satisfies Variablep)(eql function))
		      (setf b (ensure-value b))
		      (Unify (cdr a)
			     (or (cddr b) ; lisp style, e.g. (function(arg)return)
				 (cdr b)) ; probably haskell style, e.g. (function return).
			     (Extend-environment (car a) (car b) env)))
		     (((eql function)(satisfies Variablep))
		      (setf a (ensure-value a))
		      (Unify (or (cddr a) ; lisp style, e.g. (function(arg)return)
				 (cdr a)) ; probably haskell style, e.g. (function return).
			     (cdr b)
			     (Extend-environment (car b)(car a)env)))
		     (otherwise (call-next-method)))))

(defunify((a (eql 'cons))(b (eql 'list)))
  env)

(defunify((a (eql 'list))(b cl:list))
  (if(Variablep(car b))
    (Extend-environment (car b)a env)
    (if(eq a (car b)) ; list (list *)
      env
      (call-next-method))))

(defunify((a (eql 'cl:list))(b cl:list))
  (if(Variablep(car b))
    (Extend-environment (car b)a env)
    (if(string= a (car b)) ; list (list *)
      env
      (call-next-method))))

(defunify((a symbol)(b cl:list))
  (if(Variablep a)
    (if(eq 'function (car b)) ; ?B (FUNCTION(?A)?B)
      (Extend-environment a b env)
      (call-next-method))
    (if(Newtype-type-specifier-p a)
      (if(Variablep (car b))
	(if(Find-variable-value (car b) env)
	  env
	  (Extend-environment (car b) a env))
	(call-next-method))
      (call-next-method))))

(defunify((a (eql t))(b symbol))
  (if(Variablep b)
    (Extend-environment a t env)
    env))

(defun ensure-value(ftype-spec)
  (trestrul:asubst-if #'second
		      (lambda(elt)
			(typep elt '(cons (eql values) *)))
		      ftype-spec))

(defun type-match-p(t1 t2 &optional reccursivep)
  (labels((car-eq(t1 t2)
	    (matrix-case:matrix-typecase(t1 t2)
	      ((symbol symbol)(eq t1 t2))
	      ((list list)(car-eq (car t1)(car t2)))
	      ((symbol list)(car-eq t1 (car t2)))
	      ((list symbol)(car-eq (car t1)t2))))
	  )
    (matrix-case:matrix-case((category-of t1)(category-of t2))
      ((:newtype	:newtype)					(car-eq t1 t2))
      ((:newtype	(:adt :list :type-specifier :function))		nil)
      ((:adt		:adt)						(car-eq t1 t2))
      ((:adt		(:newtype :type-specifier :function :list))	nil)
      ((:type-specifier	:type-specifier)				(subtypep t1 t2))
      ((:type-specifier	(:newtype :function :list))			nil)
      ((:type-specifier	:adt)
       (when(millet:type-specifier-p t2)
	 (subtypep t1 t2)))
      ((:wildcard	t)						T)
      ((t		:wildcard)					T)
      ((:function	(:newtype :adt :type-specifier :list))		nil)
      ((:function	:function)					T)
      ((:list		:list)
       (matrix-case:matrix-etypecase(t1 t2)
	 ((list list)(loop :for e1 :in (cdr t1)
			   :for e2 :in (cdr t2)
			   :always (type-match-p e1 e2)))
	 (otherwise t)))
      ((:list		(:newtype :adt :type-specifier :function))	nil)
      ((t :satisfier)							(typep t1 t2))
      (otherwise (if reccursivep
		   nil
		   (Ignore-unification-failure(unify t1 t2)))))))

(defun category-of(thing)
  (cond
    ((Newtype-type-specifier-p thing):newtype)
    ((Adt-type-specifier-p thing) :adt)
    ((or (find thing '(* T))
	 (variablep thing))
     :wildcard)
    ((millet:type-specifier-p thing)
     (cond
       ((or (eq 'function thing)
	    (typep thing '(cons (eql function)t)))
	:function)
       ((or (eq 'list thing)
	    (eq 'cl:list thing)
	    (eq 'cons thing)
	    (typep thing '(cons (eql list)t))
	    (typep thing '(cons (eql cons)t)))
	:list)
       ((typep thing '(cons (eql satisfies)))
	:satisfier)
       (t :type-specifier)))
    (t (cond
	 ((typep thing '(cons (eql function)t)) :function)
	 ((typep thing '(cons (eql cl:list)t)) :list)
	 ((typep thing '(cons (eql cons)t)) :list)
	 (t :unknown)))))
